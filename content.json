{"meta":{"title":"Leave Me Alone","subtitle":"Heroes Never Die","description":"想做厨子和摄影师的程序员","author":"L.Scoral","url":"http://sssmarter.cn"},"pages":[{"title":"Categories","date":"2017-06-12T14:02:10.595Z","updated":"2017-06-12T14:01:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://sssmarter.cn/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-06-12T14:02:10.501Z","updated":"2017-06-12T14:00:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://sssmarter.cn/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2017-06-13T06:24:38.710Z","updated":"2017-06-13T06:24:38.710Z","comments":false,"path":"about/index.html","permalink":"http://sssmarter.cn/about/index.html","excerpt":"","text":"Here is something interesting or boring in my life. If you like the blog, you can add bookmark on your browser. L.Scoral Beijing, Capital of China Programmer who wants to be a chef and photographer. Email: lscoral.bupt@gmail.com / lscoral.bupt@outlook.com You can find me in these places: Github,ZhiHu,JianShu,Weibo These may requests VPN：Twitter,Instagram If you like Ingress,MinerCraft, contact with me. I will try my best to update this blog. To be continued…"}],"posts":[{"title":"Python-xlrd/xlwt/openpyxl","slug":"Python-xlrd-xlwt-openpyxl","date":"2017-06-15T02:39:24.000Z","updated":"2017-06-15T09:19:22.965Z","comments":true,"path":"2017/06/15/Python-xlrd-xlwt-openpyxl/","link":"","permalink":"http://sssmarter.cn/2017/06/15/Python-xlrd-xlwt-openpyxl/","excerpt":"","text":"xlrd-usage打开工作簿 1data = xlrd.open_workbook('path') 查看工作簿中的所有sheet的名称/获取工作簿多少个sheets 12data.sheet_names()data.nsheets 选择某个工作表（通过索引或表名称） 12345678#获取第一个工作表table=data.sheets()[0]#通过索引获取第一个工作表table=data.sheet_by_index(0)#通过表名称选择工作表table=data.sheet_by_name(u'哈哈') 获取表格的行数和列数,名字 123nrows = table.nrowsnclos = table.ncolsname = table.name 获取正行和整列的值 12table.row_values(number)table.col_values(number) 切片处理 1table.row_slice(rowx=0,start_colx=0,end_colx=2) 循环读取表格的所有行 123for item in range(table.nrows): print(table.row_values(item)) # 纯值 print(table.row(item)) # 包括每个值的类型 获取单元格的值 123cell_val = table.row(0)[1].valuecell_val = table.cell(0,1).valuecell_val = table.col(0)[1].value xlwt-usage新建一个Excel文件 1data = xlwt.Workbook() 新建一个工作表 1table = data.add_sheet('name') 写入数据到单元格 1table.write(0,0,u'呵呵') 注意：如果对同一个单元格重复操作，会引发overwrite Exception，想要取消该功能，需要在添加工作表时指定为可覆盖，像下面这样 1table=data.add_sheet('name',cell_overwrite_ok=True) 保存文件（不能保存为xlsx，只能用xls） 1data.save('path') xlwt支持一定的样式，操作如下 123456789101112# 初始化样式style=xlwt.XFStyle()# 为样式创建字体font=xlwt.Font()# 指定字体名字font.name='Times New Roman'# 字体加粗font.bold=True# 将该font设定为style的字体style.font=font# 写入到文件时使用该样式sheet.write(0,1,'just for test',style) openpyxl读取Excel 1from openpyxl.reader.excel import load_workbook 显示工作表的索引范围 1wb.get_named_ranges() 显示所有工作表的名字 1wb.get_sheet_names() 取得第一张表 12sheetnames = wb.get_sheet_names() ws = wb.get_sheet_by_name(sheetnames[0]) 获取表名 1ws.title 获取表的行数 1ws.get_highest_row() 获取表的列数 1ws.get_highest_column() 单元格的读取，此处和xlrd的读取方式很相近，都是通过行和列的索引来读取 12#读取B1单元格中的内容ws.cell(0,1).value 当然也支持通过Excel坐标来读取数据，代码如下 12#读取B1单元格中的内容ws.cell(\"B1\").value 写文件，只有一种操作方式，就是通过坐标。例如要向单元格C1写数据，就要用类似ws.cell(“C1”).value=something这样的方式。 一般推荐的方式是用openpyxl中的Writer类来实现。代码类似下面这样： 12345678910111213141516171819202122232425262728from openpyxl.workbook import Workbook #ExcelWriter,里面封装好了对Excel的写操作from openpyxl.writer.excel import ExcelWriter #get_column_letter函数将数字转换为相应的字母，如1--&gt;A,2--&gt;B from openpyxl.cell import get_column_letter #新建一个workbook wb = Workbook() #新建一个excelWriter ew = ExcelWriter(workbook = wb) #设置文件输出路径与名称 dest_filename = r'empty_book.xlsx' #第一个sheet是ws ws = wb.worksheets[0] #设置ws的名称 ws.title = \"range names\"#向某个单元格中写入数据ws.cell(\"C1\").value=u'哈哈'#最后保存文件ew.save(filename=dest_filename) 向某个单元格内写文件时要先知道它对应的行数和列数，这里注意行数是从1开始计数的，而列则是从字母A开始，因此第一行第一列是A1，这实际上是采用坐标方式操作Excel。例如，想向表格的第三行第一列插入一个数值1.2，用xlwt写就是table.write(2,0,1.2),因为xlwt中行列索引都从0开始；而如果用openpyxl写就是ws.cell(“A3”).value=1.2。一般对于一个较大的列数，需要通过get_column_letter函数得到相应的字符，然后再调用cell函数写入。 下面是我之前写的一个代码的一部分，可以用来演示将多位数组保存到Excel文件中。为了体现多维数组，这里用到了numpy，另外这里为了简化过程，没有用ExcelWriter。代码如下： 12345678910111213141516171819#coding:utf-8from openpyxl import Workbookfrom openpyxl.cell import get_column_letterimport numpy as np#生成一个对角阵a=np.diag([1,2,3,4,5])#新建一个工作簿wb=Workbook()#使用当前激活的工作表（默认就是Excel中的第一张表）ws=wb.active#下面是对a的遍历，注意cell中行和列从1开始，a中索引从0开始。for row in xrange(1,a.shape[0]+1): for col in xrange(1,a.shape[1]+1): col_letter=get_column_letter(col) ws.cell('%s%s'%(col_letter,row)).value=a[row-1,col-1]wb.save('test.xlsx') 总结： 读取Excel时，选择openpyxl和xlrd差别不大，都能满足要求写入少量数据且存为xls格式文件时，用xlwt更方便写入大量数据（超过xls格式限制）或者必须存为xlsx格式文件时，就要用openpyxl了。","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"xlrd","slug":"xlrd","permalink":"http://sssmarter.cn/tags/xlrd/"},{"name":"xlwt","slug":"xlwt","permalink":"http://sssmarter.cn/tags/xlwt/"},{"name":"openpyxl","slug":"openpyxl","permalink":"http://sssmarter.cn/tags/openpyxl/"}]},{"title":"Python-string","slug":"Python-string","date":"2017-06-15T02:37:54.000Z","updated":"2017-06-15T02:40:35.290Z","comments":true,"path":"2017/06/15/Python-string/","link":"","permalink":"http://sssmarter.cn/2017/06/15/Python-string/","excerpt":"","text":"string-usage","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"string","slug":"string","permalink":"http://sssmarter.cn/tags/string/"}]},{"title":"Jupyter_Notebook-Usage","slug":"Jupyter-Notebook-Usage","date":"2017-06-13T06:12:46.000Z","updated":"2017-06-14T14:41:56.000Z","comments":true,"path":"2017/06/13/Jupyter-Notebook-Usage/","link":"","permalink":"http://sssmarter.cn/2017/06/13/Jupyter-Notebook-Usage/","excerpt":"Jupyter Notebook快捷键操作 执行当前cell，并自动跳到下一个cell：Shift Enter 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 是当前的cell进入编辑模式：Enter 退出当前cell的编辑模式：Esc","text":"Jupyter Notebook快捷键操作 执行当前cell，并自动跳到下一个cell：Shift Enter 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 是当前的cell进入编辑模式：Enter 退出当前cell的编辑模式：Esc 删除当前的cell：双D 为当前的cell加入line number：单L 将当前的cell转化为具有一级标题的maskdown：单1 将当前的cell转化为具有二级标题的maskdown：单2 将当前的cell转化为具有三级标题的maskdown：单3 为一行或者多行添加/取消注释：Crtl / 撤销对某个cell的删除：z 快速跳转到首个cell：Crtl Home 快速跳转到最后一个cell：Crtl End 在代码中查找、替换，忽略输出：Esc F 在cell和输出结果间切换：Esc O 选择多个cell: Shift + J 或 Shift + Down 选择下一个cell。Shift + K 或 Shift + Up 选择上一个cell。 Shift + M 合并cell. Jupyter Notebook添加markdown目录 1conda install -c conda-forge jupyter_contrib_nbextensions 进入jupyter notebook勾选table of contents 导入代码/运行代码(current path)12%load file.py%run file.py 其他用法12!python --version 查看python版本!python file.py 运行python文件 变量显示把变量名称或没有定义输出结果的语句放在cell的最后一行，无需print语句，Jupyter也会显示变量值。 如果你想在各种情形下（Notebook和Console）Jupyter都同样处理，用下面的几行简单的命令创建文件~/.ipython/profile_default/ipython_config.py即可实现： 123c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = &quot;all&quot; 链接到文档在Help 菜单下，你可以找到常见库的在线文档链接，包括Numpy，Pandas，Scipy和Matplotlib等。另外，在库、方法或变量的前面打上?，即可打开相关语法的帮助文档。 1?str.replace() 在notebook里作图在notebook里作图，有多个选择： matplotlib （事实标准），可通过%matplotlib inline 激活，详细链接- %matplotlib notebook 提供交互性操作，但可能会有点慢，因为响应是在服务器端完成的。 mpld3 提供matplotlib代码的替代性呈现（通过d3），虽然不完整，但很好。 bokeh 生成可交互图像的更好选择。 plot.ly 可以生成非常好的图，可惜是付费服务。","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"jupyter_notebook","slug":"jupyter-notebook","permalink":"http://sssmarter.cn/tags/jupyter-notebook/"}]},{"title":"Git-learning","slug":"Git-learning","date":"2017-06-12T11:22:20.000Z","updated":"2017-06-12T14:59:34.000Z","comments":true,"path":"2017/06/12/Git-learning/","link":"","permalink":"http://sssmarter.cn/2017/06/12/Git-learning/","excerpt":"Git基础操作：本地+远程操作Step1: 初始化用户名和邮箱123安装完成之后，初始化用户名和用户邮箱：$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;","text":"Git基础操作：本地+远程操作Step1: 初始化用户名和邮箱123安装完成之后，初始化用户名和用户邮箱：$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; Step2: 初始化git仓库12初始化一个Git仓库，使用git init命令。git init Step3: git部分操作12345678910111213141516171819202122添加文件到Git仓库，分两步：- 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；- 第二步，使用命令git commit，完成。修改文件，用git diff filename 来查看被修改的文件的情况然后用同样的代码，先git add file,再git commit -m &quot;comment&quot; 提交分支git log 查看版本更迭的历史记录简化输出信息：git log --pretty=onelineHEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上一个版本，HEAD~100表示上100个版本回退使用git reset 命令git reset --hard +HEAD或者commit id可以使用git diff HEAD -- filename 来查看工作区和版本库里面最新版本的区别git checkout --file 丢弃工作区的修改git reset HEAD file 撤销暂存区的修改在工作区中删除了文件，1.同步到版本库中，用git rm file，然后再git commit -m &quot;&quot;来同步到版本库；2.需要恢复的话，则用git checkout -- file 来将版本库中的同步到工作区； Step4: 远程仓库123456789101112远程仓库：查看用户主目录下是否有.ssh目录，有的话，直接复制id_ras.pub的内容去github中添加ssh key如果没有，则用 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 创建ssh keygit添加远程管仓库：1.现在github上添加一个仓库，然后复制ssh地址；2.把本地库和github上的库关联：git remote add origin(远程仓库的名字) (ssh地址)下一步是把本地库所有的内容推送到远程库上：git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支mast推送到远程；由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。之后只需要使用git push origin master即可将本地master分支的最新修改版本推送到github Git创建并切换新的分支1234567创建并切换新的分支：git checkout -b dev上述相当于：git branch dev（创建分支） + git checkout dev（切换分支）查看当前分支：git branch切换回原分支：git checkout master合并指定分支到当前分支：git merge dev删除分支：git branch -d dev Git解决冲突123解决冲突：两条及以上分支同时做了修改首先修改文件的内容用于解决冲突，然后再重新提交原数据文件用git log --graph 可查看分支合并图 后续继续……未完待尽……","categories":[{"name":"Git","slug":"Git","permalink":"http://sssmarter.cn/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://sssmarter.cn/tags/git/"}]},{"title":"Python3-sendmail","slug":"Python3-sendmail","date":"2017-06-12T03:09:01.000Z","updated":"2017-06-12T14:58:45.000Z","comments":true,"path":"2017/06/12/Python3-sendmail/","link":"","permalink":"http://sssmarter.cn/2017/06/12/Python3-sendmail/","excerpt":"本文是使用Python3发送邮件的介绍，如要使用Python2，请进入Python2-sendmail SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。","text":"本文是使用Python3发送邮件的介绍，如要使用Python2，请进入Python2-sendmail SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 Python创建 SMTP 对象语法如下： 12import smtplibsmtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] ) 参数说明： host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如:w3cschool.cc，这个是可选参数。 port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下SMTP端口号为25。 local_hostname: 如果SMTP在你的本机上，你只需要指定服务器地址为 localhost 即可。 Python SMTP对象使用sendmail方法发送邮件，语法如下： 1SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options] 参数说明： from_addr: 邮件发送者地址。 to_addrs: 字符串列表，邮件发送地址。 msg: 发送消息 这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。 实例1：利用第三方SMTP访问发送邮件123456789101112131415161718192021222324252627import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermail_host = 'smtp.exmail.qq.com'mail_user = '***'mail_pass = '***'sender = '***'receivers = '***'message = MIMEText('Pythontest','plain','utf-8')message['From'] = Header('test1','utf-8')message['To'] = Header('test','utf-8')subject = 'python smtp test'message['Subject'] = Header(subject,'utf-8')try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host,25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender,receivers,message.as_string()) print('success')except smtplib.SMTPException: print('failed') 实例2：使用Python发送HTML格式的邮件Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下： 12345678910111213141516171819202122232425262728293031import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermail_host = 'smtp.exmail.qq.com'mail_user = 'zhijie.liao@dmall.com'mail_pass = 'Smarter1025@#'sender = 'zhijie.liao@dmall.com'receivers = 'zhijie.liao@dmall.com'mail_msg = '''&lt;p&gt;Python邮件发送测试&lt;/p&gt;&lt;p&gt;&lt;a href=\"sssmarter.cn\"&gt;我的博客&lt;/a&gt;&lt;/p&gt;'''message = MIMEText(mail_msg,'html','utf-8')message['From'] = Header('test1','utf-8')message['To'] = Header('test','utf-8')subject = 'python smtp test'message['Subject'] = Header(subject,'utf-8')try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host,25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender,receivers,message.as_string()) print('success')except smtplib.SMTPException: print('failed') 实例3：Python 发送带附件的邮件12345678910111213141516171819202122232425262728293031323334353637import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message['From'] = Header(\"test1\", 'utf-8')message['To'] = Header(\"test2\", 'utf-8')subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8') #邮件正文内容message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')att1[\"Content-Type\"] = 'application/octet-stream'# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1[\"Content-Disposition\"] = 'attachment; filename=\"test.txt\"'message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')att2[\"Content-Type\"] = 'application/octet-stream'att2[\"Content-Disposition\"] = 'attachment; filename=\"runoob.txt\"'message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print (\"邮件发送成功\")except smtplib.SMTPException: print (\"Error: 无法发送邮件\") 实例4：使用QQ邮箱的SMTP服务发送邮件12345678910111213141516171819202122232425262728import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddr my_sender='zhijie.liao@dmall.com' # 发件人邮箱账号my_pass = '***' # 发件人邮箱密码my_user='zhijie.liao@dmall.com' # 收件人邮箱账号，我这边发送给自己def mail(): ret=True try: msg=MIMEText('填写邮件内容','plain','utf-8') msg['From']=formataddr([\"FromRunoob\",my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['To']=formataddr([\"FK\",my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['Subject']=\"菜鸟教程发送邮件测试\" # 邮件的主题，也可以说是标题 server=smtplib.SMTP(\"smtp.exmail.qq.com\", 25) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender,my_user,msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret=False return ret ret=mail()if ret: print(\"邮件发送成功\")else: print(\"邮件发送失败\") 好了！到这里本文就结束了！这里就是我的底线！","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"mail","slug":"mail","permalink":"http://sssmarter.cn/tags/mail/"}]},{"title":"《算命》-徐童","slug":"《算命》-徐童","date":"2017-06-11T15:42:01.000Z","updated":"2017-06-12T14:59:08.000Z","comments":true,"path":"2017/06/11/《算命》-徐童/","link":"","permalink":"http://sssmarter.cn/2017/06/11/《算命》-徐童/","excerpt":"赶这个双休日，把之前下载下来保存很久的徐童的纪录片《算命》看完了。","text":"赶这个双休日，把之前下载下来保存很久的徐童的纪录片《算命》看完了。 整个视频在不到3个小时的时间里，分成八个章节，每个章节一个阶段性的故事。整个纪录片以算命为线索，讲述每一个来历百程这里算命的人的故事，同时也穿插了一些其他的事情。从一开始在红灯区开店的老板娘的故事，到最后说到历百程自己被迫无奈回家住宿，之后又重新外出找活计的事情。纪录片很俗，是真的很俗，俗到了土里，却也俗得让人难受。 有一个很深的印象，本以为历百程照料石珍珠真的是可怜她，但是在最后他自己也道出了真相。当初就是想女人，图一时痛快，就为了弄一下，现在成了一个包袱，但你说现在再给她赶走？那也不忍心啊… 没有静下心来细细地去想视频的每一个细节，所以也就作罢了，不想去挖空脑袋想措辞，完成这一篇推送~感觉自己还是涉世太浅，未经世间百事，岂能凭心而谈。 看完之后去知乎看了评价，感觉想照搬过来放上，但又怕侵犯了别人的知识产权，所以贴上链接，留个记录吧~[https://www.zhihu.com/question/21290531?sort=created]","categories":[{"name":"Movies","slug":"Movies","permalink":"http://sssmarter.cn/categories/Movies/"}],"tags":[{"name":"documentary","slug":"documentary","permalink":"http://sssmarter.cn/tags/documentary/"},{"name":"impressive","slug":"impressive","permalink":"http://sssmarter.cn/tags/impressive/"}]},{"title":"Python2-sendmail","slug":"Python2-sendmail","date":"2017-06-11T06:58:34.000Z","updated":"2017-06-12T13:55:43.000Z","comments":true,"path":"2017/06/11/Python2-sendmail/","link":"","permalink":"http://sssmarter.cn/2017/06/11/Python2-sendmail/","excerpt":"本代码适用于Python2环境，Python3环境请参考其他 补充：Python3发送邮件请查看Python3-sendmail 以下是相关代码：","text":"本代码适用于Python2环境，Python3环境请参考其他 补充：Python3发送邮件请查看Python3-sendmail 以下是相关代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#!/usr/bin/env python# -*- coding: UTF-8 -*-from email.mime.multipart import MIMEMultipartfrom email.mime.base import MIMEBasefrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.utils import COMMASPACE,formatdatefrom email import encodersimport osimport sysimport getoptreload(sys)sys.setdefaultencoding('utf8')#server['name'], server['user'], server['passwd']def send_mail(server, fro, to, subject, content,content_type='html', files=[],pics=&#123;&#125;): assert type(server) == dict assert type(to) == list assert type(files) == list assert type(pics) == dict msg = MIMEMultipart() msg['From'] = fro if not isinstance(subject,unicode): subject = unicode(subject) msg['Subject'] = subject msg['To'] = COMMASPACE.join(to) msg['Date'] = formatdate(localtime=True) msg.attach(MIMEText(content,content_type,'utf-8')) for file in files: part = MIMEBase('application', 'octet-stream') part.set_payload(open(file, 'rb').read()) encoders.encode_base64(part) part.add_header('Content-Disposition', 'attachment; filename=\"%s\"' % os.path.basename(file)) msg.attach(part) for k,v in pics.items(): fp = open(k, 'rb') msgImage = MIMEImage(fp.read()) fp.close() msgImage.add_header('Content-ID', v) msg.attach(msgImage) import smtplib smtp = smtplib.SMTP(server['name']) smtp.login(server['user'], server['passwd']) smtp.sendmail(fro, to, msg.as_string()) smtp.close()def send(to, subject, content,content_type='html', files=[],pics=&#123;&#125;): server = &#123;&#125; server['name'] ='smtp.exmail.qq.com' server['user'] = 'email address' server['passwd'] = 'passwd' send_mail(server,'email address',to, subject, content,content_type,files,pics)def useage(): print '--title 邮件标题,不可少选项' print '--to 收件人列表，逗号分隔多个账户' print '--content 邮件内容' print '--attachs 附件列表，逗号分隔多个附件' print '--type 取值:html,plain两种，默认html' print '''--pics 正文中图片，字典格式：&#123;\"图片路径\",\"图片标识（eg:&lt;imgage1&gt;正文中使用&lt;img src='cid:imgage1' &gt;来引用，标识两侧尖括号不能少）\"&#125;'''def main(argv): try: opts,args = getopt.getopt(argv[1:],'',['to=','title=','content=','attachs=','type=','pics=']) except getopt.GetoptError, err: print str(err) print useage() sys.exit(2) title = '' tolist = [] content = '' attachs = [] type = 'html' pics = &#123;&#125; for k,v in opts: if k == '--title': title = v if k == '--to': tolist = v.split(\",\") elif k == '--content': content = v elif k == '--attachs': attachs = v.split(\",\") elif k == '--type': type = v elif k == '--pics': pics = eval(v) if title == '': print 'please input title...' sys.exit(1) if type not in ('html','plain'): print 'content type only supports:html,plain...' sys.exit(1) if tolist == []: print 'please input mail receiver...' sys.exit(1) send(tolist, title, content,type, attachs,pics)if __name__ == '__main__': main(sys.argv)","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"mail","slug":"mail","permalink":"http://sssmarter.cn/tags/mail/"}]},{"title":"Python-format Usage","slug":"Python-format","date":"2017-06-09T01:17:18.000Z","updated":"2017-06-12T14:58:20.000Z","comments":true,"path":"2017/06/09/Python-format/","link":"","permalink":"http://sssmarter.cn/2017/06/09/Python-format/","excerpt":"foramt函数：“映射”示例通过位置123456In [1]: '&#123;0&#125;,&#123;1&#125;'.format('kzc',18)Out[1]: 'kzc,18' In [2]: '&#123;&#125;,&#123;&#125;'.format('kzc',18) Out[2]: 'kzc,18' In [3]: '&#123;1&#125;,&#123;0&#125;,&#123;1&#125;'.format('kzc',18) Out[3]: '18,kzc,18'","text":"foramt函数：“映射”示例通过位置123456In [1]: '&#123;0&#125;,&#123;1&#125;'.format('kzc',18)Out[1]: 'kzc,18' In [2]: '&#123;&#125;,&#123;&#125;'.format('kzc',18) Out[2]: 'kzc,18' In [3]: '&#123;1&#125;,&#123;0&#125;,&#123;1&#125;'.format('kzc',18) Out[3]: '18,kzc,18' 字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次，不过2.6不能为空{}，2.7才可以。 通过关键字参数1In [5]: '&#123;name&#125;,&#123;age&#125;'.format(age=18,name='kzc') Out[5]: 'kzc,18' 通过对象属性12class Person: def init(self,name,age): self.name,self.age = name,age def str(self): return 'This guy is &#123;self.name&#125;,is &#123;self.age&#125; old'.format(self=self)In [2]: str(Person('kzc',18)) Out[2]: 'This guy is kzc,is 18 old' 通过下标12In [7]: p=['kzc',18] In [8]: '&#123;0[0]&#125;,&#123;0[1]&#125;'.format(p) Out[8]: 'kzc,18' 有了这些便捷的“映射”方式，我们就有了偷懒利器。基本的python知识告诉我们，list和tuple可以通过“打散”成普通参数给函数，而dict可以打散成关键字参数给函数（通过和*）。所以可以轻松的传个list/tuple/dict给format函数。非常灵活。 格式限定符它有着丰富的的“格式限定符”（语法是{}中带:号），比如：填充与对齐填充常跟对齐一起使用^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充，比如 123456In [15]: '&#123;:&gt;8&#125;'.format('189') Out[15]: ' 189' In [16]: '&#123;:0&gt;8&#125;'.format('189') Out[16]: '00000189' In [17]: '&#123;:a&gt;8&#125;'.format('189') Out[17]: 'aaaaa189' 精度与类型f精度常跟类型f一起使用 12In [44]: '&#123;:.2f&#125;'.format(321.33345) Out[44]: '321.33' 其中.2表示长度为2的精度，f表示float类型。 其他类型主要就是进制了，b、d、o、x分别是二进制、十进制、八进制、十六进制。 12345678In [54]: '&#123;:b&#125;'.format(17) Out[54]: '10001' In [55]: '&#123;:d&#125;'.format(17) Out[55]: '17' In [56]: '&#123;:o&#125;'.format(17)Out[56]: '21' In [57]: '&#123;:x&#125;'.format(17) Out[57]: '11' 用，号还能用来做金额的千位分隔符。 12In [47]: '&#123;:,&#125;'.format(1234567890)Out[47]: '1,234,567,890'","categories":[{"name":"Python","slug":"Python","permalink":"http://sssmarter.cn/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://sssmarter.cn/tags/python/"},{"name":"format","slug":"format","permalink":"http://sssmarter.cn/tags/format/"}]}]}