<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Atom-package-Hydrogen]]></title>
    <url>%2F2017%2F07%2F11%2FAtom-package-Hydrogen%2F</url>
    <content type="text"><![CDATA[UsageHydrogen provides a selection of commands for running code. Press ⌘-⇧-P to open the command palette and type “hydrogen” and they will come up. “Hydrogen: Run”There are two ways to tell Hydrogen which code in your file to run. Selected code: If you have code selected when you hit Run, Hydrogen will run exactly that code. Current block: With no code selected, Hydrogen will try to find the complete block that’s on or before the current line. If the line you’re on is already a complete expression (like s = &quot;abracadabra&quot;), Hydrogen will run just that line. If the line you’re on is the start of a block like a for loop, Hydrogen will run the whole block. If the line you’re on is blank, Hydrogen will run the first block above that line. It’s easiest to see these interactions visually: “Hydrogen: Run And Move Down” will run the the code as described above and move the cursor to the next executable line. If your code starts getting cluttered up with results, run “Hydrogen: Clear Results” to remove them all at once. “Hydrogen: Run Cell”A “code cell” is a block of lines to be executed at once. You can define them using inline comments. Hydrogen supports amultitude of ways to define cells. Pick the one you like best.The following is an example for python but it will work in any language, just replace # with the comment symbol for your desired language: When you place the cursor inside a cell and hit “Run Cell”, Hydrogen will execute this cell. The command “Hydrogen: Run Cell And Move Down” will move the cursor to the next cell after execution. “Hydrogen: Run All” and “Hydrogen: Run All Above”These commands will run all code inside the editor or all code above the cursor. “Hydrogen: Restart Kernel And Re Evaluate Bubbles”Restart running kernel and re-evaluate all bubbles on editor.This command works in following way. Restart kernel to cleanup evaluation environment. Run all code and update all existing bubbles. “Hydrogen: Toggle Bubble”Toggle(add or remove) bobble at current cursor line.You can preset bubble before executing code.If executed with selection, toggle bubble on each selected line. Typical workflow with this command is Add bubble at line you want manually by hydrogen:toggle-bubble Execute code cleanly by restart-kernel-and-re-evaluate-bubbles Modify code, then repeat 1-3 until you fully understand/investigated code. Watch ExpressionsAfter you’ve run some code with Hydrogen, you can use the “Hydrogen: Toggle Watches” command from the Command Palette to open the watch expression sidebar. Whatever code you write in watch expressions will be re-run after each time you send that kernel any other code. IMPORTANT: Be careful what you put in your watch expressions. If you write code that mutates state in a watch expression, that code will get run after every execute command and likely result in some extremely confusing bugs. You can re-run the watch expressions by using the normal run shortcut (⌘-↩ by default) inside a watch expression’s edit field. If you have multiple kernels running, you can switch between their watch expressions with the “Hydrogen: Select Watch Kernel” command (or just click on the “Kernel: “ text). CompletionReceive completions from the running kernel. Code IntrospectionYou can use the “Hydrogen: Toggle Inspector” command from the Command Palette to get metadata from the kernel about the object under the cursor. Managing kernelsSometimes things go wrong. Maybe you’ve written an infinite loop, maybe the kernel has crashed, or maybe you just want to clear the kernel’s namespace. Use the command palette to interrupt (think Ctrl-C in a REPL) or restart the kernel. You can also access these commands by clicking on the kernel status in the status bar or via the command palette. It looks like this: Additionally, if you have two or more kernels for a particular language (grammar), you can select which kernel to use with the “Switch to “ option in the Kernel Commands menu. Multiple kernels inside one rich documentIf you are working in a markup file that supports highlighted code blocks, we can handle multiple kernels per file. This way you can write your documentation, readme or paper together with your code while retaining the interactivity of Hydrogen. We support markdown, gfm, asciidoc, reStructuredText and knitr.]]></content>
      <categories>
        <category>Atom</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Atom-package-Multi_cursor]]></title>
    <url>%2F2017%2F07%2F11%2FAtom-package-multi_cursor%2F</url>
    <content type="text"><![CDATA[Multi-cursor package An atom package to easily create more cursors with keystrokes. OSX Keymaps: Creating cursorsalt + up = Create cursor abovealt + down = Create cursor under Moving the last cursor that has been createdctrl + alt + up = Move the last-created cursor upctrl + alt + down = Move the last-created cursor downctrl + alt + left = Move the last-created cursor leftctrl + alt + right = Move the last-created cursor right Linux Keymaps: Creating cursorsctrl + shift + up = Create cursor abovectrl + shift + down = Create cursor under Moving the last cursor that has been createdctrl + shift + alt + up = Move the last-created cursor upctrl + shift + alt + down = Move the last-created cursor downctrl + shift + alt + left = Move the last-created cursor leftctrl + shift + alt + right = Move the last-created cursor right Windows Keymaps: Creating cursorsalt + up = Create cursor abovealt + down = Create cursor under Moving the last cursor that has been createdctrl + shift + alt + up = Move the last-created cursor upctrl + shift + alt + down = Move the last-created cursor downctrl + shift + alt + left = Move the last-created cursor leftctrl + shift + alt + right = Move the last-created cursor right Those may be overriden for your favorite keystroke in your keymap.cson with: 123456789101112&apos;atom-workspace atom-text-editor:not([mini])&apos;: # you may have to unset the keybinding if it&apos;s already in use. # Expand current cursor &apos;ctrl-down&apos;: &apos;multi-cursor:expandDown&apos; &apos;ctrl-up&apos;: &apos;multi-cursor:expandUp&apos; # Move the last cursor. &apos;ctrl-alt-down&apos;: &apos;multi-cursor:move-last-cursor-down&apos; &apos;ctrl-alt-right&apos;: &apos;multi-cursor:move-last-cursor-right&apos; &apos;ctrl-alt-left&apos;: &apos;multi-cursor:move-last-cursor-left&apos; &apos;ctrl-alt-up&apos;: &apos;multi-cursor:move-last-cursor-up&apos;]]></content>
      <categories>
        <category>Atom</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python-xlrd/xlwt/openpyxl]]></title>
    <url>%2F2017%2F06%2F15%2FPython-xlrd-xlwt-openpyxl%2F</url>
    <content type="text"><![CDATA[xlrd-usage打开工作簿 1data = xlrd.open_workbook('path') 查看工作簿中的所有sheet的名称/获取工作簿多少个sheets 12data.sheet_names()data.nsheets 选择某个工作表（通过索引或表名称） 12345678#获取第一个工作表table=data.sheets()[0]#通过索引获取第一个工作表table=data.sheet_by_index(0)#通过表名称选择工作表table=data.sheet_by_name(u'哈哈') 获取表格的行数和列数,名字 123nrows = table.nrowsnclos = table.ncolsname = table.name 获取正行和整列的值 12table.row_values(number)table.col_values(number) 切片处理 1table.row_slice(rowx=0,start_colx=0,end_colx=2) 循环读取表格的所有行 123for item in range(table.nrows): print(table.row_values(item)) # 纯值 print(table.row(item)) # 包括每个值的类型 获取单元格的值 123cell_val = table.row(0)[1].valuecell_val = table.cell(0,1).valuecell_val = table.col(0)[1].value xlwt-usage新建一个Excel文件 1data = xlwt.Workbook() 新建一个工作表 1table = data.add_sheet('name') 写入数据到单元格 1table.write(0,0,u'呵呵') 注意：如果对同一个单元格重复操作，会引发overwrite Exception，想要取消该功能，需要在添加工作表时指定为可覆盖，像下面这样 1table=data.add_sheet('name',cell_overwrite_ok=True) 保存文件（不能保存为xlsx，只能用xls） 1data.save('path') xlwt支持一定的样式，操作如下 123456789101112# 初始化样式style=xlwt.XFStyle()# 为样式创建字体font=xlwt.Font()# 指定字体名字font.name='Times New Roman'# 字体加粗font.bold=True# 将该font设定为style的字体style.font=font# 写入到文件时使用该样式sheet.write(0,1,'just for test',style) openpyxl读取Excel 1from openpyxl.reader.excel import load_workbook 显示工作表的索引范围 1wb.get_named_ranges() 显示所有工作表的名字 1wb.get_sheet_names() 取得第一张表 12sheetnames = wb.get_sheet_names() ws = wb.get_sheet_by_name(sheetnames[0]) 获取表名 1ws.title 获取表的行数 1ws.get_highest_row() 获取表的列数 1ws.get_highest_column() 单元格的读取，此处和xlrd的读取方式很相近，都是通过行和列的索引来读取 12#读取B1单元格中的内容ws.cell(0,1).value 当然也支持通过Excel坐标来读取数据，代码如下 12#读取B1单元格中的内容ws.cell("B1").value 写文件，只有一种操作方式，就是通过坐标。例如要向单元格C1写数据，就要用类似ws.cell(“C1”).value=something这样的方式。 一般推荐的方式是用openpyxl中的Writer类来实现。代码类似下面这样： 12345678910111213141516171819202122232425262728from openpyxl.workbook import Workbook #ExcelWriter,里面封装好了对Excel的写操作from openpyxl.writer.excel import ExcelWriter #get_column_letter函数将数字转换为相应的字母，如1--&gt;A,2--&gt;B from openpyxl.cell import get_column_letter #新建一个workbook wb = Workbook() #新建一个excelWriter ew = ExcelWriter(workbook = wb) #设置文件输出路径与名称 dest_filename = r'empty_book.xlsx' #第一个sheet是ws ws = wb.worksheets[0] #设置ws的名称 ws.title = "range names"#向某个单元格中写入数据ws.cell("C1").value=u'哈哈'#最后保存文件ew.save(filename=dest_filename) 向某个单元格内写文件时要先知道它对应的行数和列数，这里注意行数是从1开始计数的，而列则是从字母A开始，因此第一行第一列是A1，这实际上是采用坐标方式操作Excel。例如，想向表格的第三行第一列插入一个数值1.2，用xlwt写就是table.write(2,0,1.2),因为xlwt中行列索引都从0开始；而如果用openpyxl写就是ws.cell(“A3”).value=1.2。一般对于一个较大的列数，需要通过get_column_letter函数得到相应的字符，然后再调用cell函数写入。 下面是我之前写的一个代码的一部分，可以用来演示将多位数组保存到Excel文件中。为了体现多维数组，这里用到了numpy，另外这里为了简化过程，没有用ExcelWriter。代码如下： 12345678910111213141516171819#coding:utf-8from openpyxl import Workbookfrom openpyxl.cell import get_column_letterimport numpy as np#生成一个对角阵a=np.diag([1,2,3,4,5])#新建一个工作簿wb=Workbook()#使用当前激活的工作表（默认就是Excel中的第一张表）ws=wb.active#下面是对a的遍历，注意cell中行和列从1开始，a中索引从0开始。for row in xrange(1,a.shape[0]+1): for col in xrange(1,a.shape[1]+1): col_letter=get_column_letter(col) ws.cell('%s%s'%(col_letter,row)).value=a[row-1,col-1]wb.save('test.xlsx') 总结： 读取Excel时，选择openpyxl和xlrd差别不大，都能满足要求写入少量数据且存为xls格式文件时，用xlwt更方便写入大量数据（超过xls格式限制）或者必须存为xlsx格式文件时，就要用openpyxl了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>xlrd</tag>
        <tag>xlwt</tag>
        <tag>openpyxl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-string]]></title>
    <url>%2F2017%2F06%2F15%2FPython-string%2F</url>
    <content type="text"><![CDATA[string-usage]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter_Notebook-Usage]]></title>
    <url>%2F2017%2F06%2F13%2FJupyter-Notebook-Usage%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook快捷键操作 执行当前cell，并自动跳到下一个cell：Shift Enter 执行当前cell，执行后不自动调转到下一个cell：Ctrl-Enter 是当前的cell进入编辑模式：Enter 退出当前cell的编辑模式：Esc 删除当前的cell：双D 为当前的cell加入line number：单L 将当前的cell转化为具有一级标题的maskdown：单1 将当前的cell转化为具有二级标题的maskdown：单2 将当前的cell转化为具有三级标题的maskdown：单3 为一行或者多行添加/取消注释：Crtl / 撤销对某个cell的删除：z 快速跳转到首个cell：Crtl Home 快速跳转到最后一个cell：Crtl End 在代码中查找、替换，忽略输出：Esc F 在cell和输出结果间切换：Esc O 选择多个cell: Shift + J 或 Shift + Down 选择下一个cell。Shift + K 或 Shift + Up 选择上一个cell。 Shift + M 合并cell. Jupyter Notebook添加markdown目录 1conda install -c conda-forge jupyter_contrib_nbextensions 进入jupyter notebook勾选table of contents 导入代码/运行代码(current path)12%load file.py%run file.py 其他用法12!python --version 查看python版本!python file.py 运行python文件 变量显示把变量名称或没有定义输出结果的语句放在cell的最后一行，无需print语句，Jupyter也会显示变量值。 如果你想在各种情形下（Notebook和Console）Jupyter都同样处理，用下面的几行简单的命令创建文件~/.ipython/profile_default/ipython_config.py即可实现： 123c = get_config()# Run all nodes interactivelyc.InteractiveShell.ast_node_interactivity = &quot;all&quot; 链接到文档在Help 菜单下，你可以找到常见库的在线文档链接，包括Numpy，Pandas，Scipy和Matplotlib等。另外，在库、方法或变量的前面打上?，即可打开相关语法的帮助文档。 1?str.replace() 在notebook里作图在notebook里作图，有多个选择： matplotlib （事实标准），可通过%matplotlib inline 激活，详细链接- %matplotlib notebook 提供交互性操作，但可能会有点慢，因为响应是在服务器端完成的。 mpld3 提供matplotlib代码的替代性呈现（通过d3），虽然不完整，但很好。 bokeh 生成可交互图像的更好选择。 plot.ly 可以生成非常好的图，可惜是付费服务。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>jupyter_notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-learning]]></title>
    <url>%2F2017%2F06%2F12%2FGit-learning%2F</url>
    <content type="text"><![CDATA[Git基础操作：本地+远程操作Step1: 初始化用户名和邮箱123安装完成之后，初始化用户名和用户邮箱：$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; Step2: 初始化git仓库12初始化一个Git仓库，使用git init命令。git init Step3: git部分操作12345678910111213141516171819202122添加文件到Git仓库，分两步：- 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；- 第二步，使用命令git commit，完成。修改文件，用git diff filename 来查看被修改的文件的情况然后用同样的代码，先git add file,再git commit -m &quot;comment&quot; 提交分支git log 查看版本更迭的历史记录简化输出信息：git log --pretty=onelineHEAD表示当前版本，HEAD^表示上一版本，HEAD^^表示上上一个版本，HEAD~100表示上100个版本回退使用git reset 命令git reset --hard +HEAD或者commit id可以使用git diff HEAD -- filename 来查看工作区和版本库里面最新版本的区别git checkout --file 丢弃工作区的修改git reset HEAD file 撤销暂存区的修改在工作区中删除了文件，1.同步到版本库中，用git rm file，然后再git commit -m &quot;&quot;来同步到版本库；2.需要恢复的话，则用git checkout -- file 来将版本库中的同步到工作区； Step4: 远程仓库123456789101112远程仓库：查看用户主目录下是否有.ssh目录，有的话，直接复制id_ras.pub的内容去github中添加ssh key如果没有，则用 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 创建ssh keygit添加远程管仓库：1.现在github上添加一个仓库，然后复制ssh地址；2.把本地库和github上的库关联：git remote add origin(远程仓库的名字) (ssh地址)下一步是把本地库所有的内容推送到远程库上：git push -u origin master把本地库的内容推送到远程，用git push命令，实际上是把当前分支mast推送到远程；由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。之后只需要使用git push origin master即可将本地master分支的最新修改版本推送到github Git创建并切换新的分支1234567创建并切换新的分支：git checkout -b dev上述相当于：git branch dev（创建分支） + git checkout dev（切换分支）查看当前分支：git branch切换回原分支：git checkout master合并指定分支到当前分支：git merge dev删除分支：git branch -d dev Git解决冲突12345678910解决冲突：两条及以上分支同时做了修改首先修改文件的内容用于解决冲突，然后再重新提交原数据文件用git log --graph 可查看分支合并图$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test Git分支管理策略12345通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面合并分支，因为要创建新的commit，所以添加-mgit merge --no-ff -m &quot;merge with no-ff&quot; dev Git-BUG分支12345将暂未完成的工作用git stash&apos;储藏&apos;起来，然后从master上创建新的分支进行BUG修复，修复完成之后再合并到master分支，然后删除修复bug用的分支；这时再重新切换到dev分支上，使用git stash list列出之前存储的操作内容，git stash apply恢复，但是恢复后，stash内容并不删除；git stash pop，恢复的同时把stash内容也删除。 强行删除分支12开发新功能，建议重新建立一个分支；如果要删除这个未合并的分支，用git branch -D feature 查看远程仓库，多人协作12git remote 或者 git remote -v用于查看远程仓库的信息 git push origin master/dev 推送相应的本地分支到远程对应的分支 Git标签管理1234567891011121314151617181920创建标签 git tag v1.0 默认标签是打在最新提交的commit上的。如果忘了打标签，可以通过查找历史的commit id，然后打上就可以，如下：git tag v0.9 commit id用git show &lt;tagname&gt; 来查看标签的信息；创建有说明的标签，用-a指定标签名，-m指定说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164还可以通过-s用私钥签名一个标签git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a使用git tag -d v0.1 删除标签因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;；一次性推送全部尚未推送到远程的本地标签：git push origin --tags如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：$ git tag -d v0.9然后，从远程删除。删除命令也是push，但是格式如下：$ git push origin :refs/tags/v0.9 Git忽略文件1在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 Git配置别名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051有没有经常敲错命令？比如git status？status这个单词真心不好记。我们只需要敲一行命令，告诉Git，以后st就表示status：$ git config --global alias.st status当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch$ git config --global alias.unstage &apos;reset HEAD&apos;$ git config --global alias.last &apos;log -1&apos;这样，用git last就能显示最近一次的提交：甚至还有人丧心病狂地把lg配置成了：git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;配置文件配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：$ cat .git/config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 可能这是命吧，看着教程自己总结，最后一些直接复制粘贴过来了，凑合着看看，反正也是为了留个存根，自己以后看起来方便。本文结束，到此为止。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3-sendmail]]></title>
    <url>%2F2017%2F06%2F12%2FPython3-sendmail%2F</url>
    <content type="text"><![CDATA[本文是使用Python3发送邮件的介绍，如要使用Python2，请进入Python2-sendmail SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 Python创建 SMTP 对象语法如下： 12import smtplibsmtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] ) 参数说明： host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如:w3cschool.cc，这个是可选参数。 port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下SMTP端口号为25。 local_hostname: 如果SMTP在你的本机上，你只需要指定服务器地址为 localhost 即可。 Python SMTP对象使用sendmail方法发送邮件，语法如下： 1SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options] 参数说明： from_addr: 邮件发送者地址。 to_addrs: 字符串列表，邮件发送地址。 msg: 发送消息 这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。 实例1：利用第三方SMTP访问发送邮件123456789101112131415161718192021222324252627import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermail_host = 'smtp.exmail.qq.com'mail_user = '***'mail_pass = '***'sender = '***'receivers = '***'message = MIMEText('Pythontest','plain','utf-8')message['From'] = Header('test1','utf-8')message['To'] = Header('test','utf-8')subject = 'python smtp test'message['Subject'] = Header(subject,'utf-8')try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host,25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender,receivers,message.as_string()) print('success')except smtplib.SMTPException: print('failed') 实例2：使用Python发送HTML格式的邮件Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下： 12345678910111213141516171819202122232425262728293031import smtplibfrom email.mime.text import MIMETextfrom email.header import Headermail_host = 'smtp.exmail.qq.com'mail_user = 'zhijie.liao@dmall.com'mail_pass = 'Smarter1025@#'sender = 'zhijie.liao@dmall.com'receivers = 'zhijie.liao@dmall.com'mail_msg = '''&lt;p&gt;Python邮件发送测试&lt;/p&gt;&lt;p&gt;&lt;a href="sssmarter.cn"&gt;我的博客&lt;/a&gt;&lt;/p&gt;'''message = MIMEText(mail_msg,'html','utf-8')message['From'] = Header('test1','utf-8')message['To'] = Header('test','utf-8')subject = 'python smtp test'message['Subject'] = Header(subject,'utf-8')try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host,25) smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender,receivers,message.as_string()) print('success')except smtplib.SMTPException: print('failed') 实例3：Python 发送带附件的邮件12345678910111213141516171819202122232425262728293031323334353637import smtplibfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.header import Header sender = 'from@runoob.com'receivers = ['429240967@qq.com'] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例message = MIMEMultipart()message['From'] = Header("test1", 'utf-8')message['To'] = Header("test2", 'utf-8')subject = 'Python SMTP 邮件测试'message['Subject'] = Header(subject, 'utf-8') #邮件正文内容message.attach(MIMEText('这是菜鸟教程Python 邮件发送测试……', 'plain', 'utf-8')) # 构造附件1，传送当前目录下的 test.txt 文件att1 = MIMEText(open('test.txt', 'rb').read(), 'base64', 'utf-8')att1["Content-Type"] = 'application/octet-stream'# 这里的filename可以任意写，写什么名字，邮件中显示什么名字att1["Content-Disposition"] = 'attachment; filename="test.txt"'message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件att2 = MIMEText(open('runoob.txt', 'rb').read(), 'base64', 'utf-8')att2["Content-Type"] = 'application/octet-stream'att2["Content-Disposition"] = 'attachment; filename="runoob.txt"'message.attach(att2) try: smtpObj = smtplib.SMTP('localhost') smtpObj.sendmail(sender, receivers, message.as_string()) print ("邮件发送成功")except smtplib.SMTPException: print ("Error: 无法发送邮件") 实例4：使用QQ邮箱的SMTP服务发送邮件12345678910111213141516171819202122232425262728import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddr my_sender='zhijie.liao@dmall.com' # 发件人邮箱账号my_pass = '***' # 发件人邮箱密码my_user='zhijie.liao@dmall.com' # 收件人邮箱账号，我这边发送给自己def mail(): ret=True try: msg=MIMEText('填写邮件内容','plain','utf-8') msg['From']=formataddr(["FromRunoob",my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['To']=formataddr(["FK",my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['Subject']="菜鸟教程发送邮件测试" # 邮件的主题，也可以说是标题 server=smtplib.SMTP("smtp.exmail.qq.com", 25) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender,my_user,msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret=False return ret ret=mail()if ret: print("邮件发送成功")else: print("邮件发送失败") 好了！到这里本文就结束了！这里就是我的底线！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算命》-徐童]]></title>
    <url>%2F2017%2F06%2F11%2F%E3%80%8A%E7%AE%97%E5%91%BD%E3%80%8B-%E5%BE%90%E7%AB%A5%2F</url>
    <content type="text"><![CDATA[赶这个双休日，把之前下载下来保存很久的徐童的纪录片《算命》看完了。 整个视频在不到3个小时的时间里，分成八个章节，每个章节一个阶段性的故事。整个纪录片以算命为线索，讲述每一个来历百程这里算命的人的故事，同时也穿插了一些其他的事情。从一开始在红灯区开店的老板娘的故事，到最后说到历百程自己被迫无奈回家住宿，之后又重新外出找活计的事情。纪录片很俗，是真的很俗，俗到了土里，却也俗得让人难受。 有一个很深的印象，本以为历百程照料石珍珠真的是可怜她，但是在最后他自己也道出了真相。当初就是想女人，图一时痛快，就为了弄一下，现在成了一个包袱，但你说现在再给她赶走？那也不忍心啊… 没有静下心来细细地去想视频的每一个细节，所以也就作罢了，不想去挖空脑袋想措辞，完成这一篇推送~感觉自己还是涉世太浅，未经世间百事，岂能凭心而谈。 看完之后去知乎看了评价，感觉想照搬过来放上，但又怕侵犯了别人的知识产权，所以贴上链接，留个记录吧~[https://www.zhihu.com/question/21290531?sort=created]]]></content>
      <categories>
        <category>Movies</category>
      </categories>
      <tags>
        <tag>documentary</tag>
        <tag>impressive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2-sendmail]]></title>
    <url>%2F2017%2F06%2F11%2FPython2-sendmail%2F</url>
    <content type="text"><![CDATA[本代码适用于Python2环境，Python3环境请参考其他 补充：Python3发送邮件请查看Python3-sendmail 以下是相关代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#!/usr/bin/env python# -*- coding: UTF-8 -*-from email.mime.multipart import MIMEMultipartfrom email.mime.base import MIMEBasefrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.utils import COMMASPACE,formatdatefrom email import encodersimport osimport sysimport getoptreload(sys)sys.setdefaultencoding('utf8')#server['name'], server['user'], server['passwd']def send_mail(server, fro, to, subject, content,content_type='html', files=[],pics=&#123;&#125;): assert type(server) == dict assert type(to) == list assert type(files) == list assert type(pics) == dict msg = MIMEMultipart() msg['From'] = fro if not isinstance(subject,unicode): subject = unicode(subject) msg['Subject'] = subject msg['To'] = COMMASPACE.join(to) msg['Date'] = formatdate(localtime=True) msg.attach(MIMEText(content,content_type,'utf-8')) for file in files: part = MIMEBase('application', 'octet-stream') part.set_payload(open(file, 'rb').read()) encoders.encode_base64(part) part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(file)) msg.attach(part) for k,v in pics.items(): fp = open(k, 'rb') msgImage = MIMEImage(fp.read()) fp.close() msgImage.add_header('Content-ID', v) msg.attach(msgImage) import smtplib smtp = smtplib.SMTP(server['name']) smtp.login(server['user'], server['passwd']) smtp.sendmail(fro, to, msg.as_string()) smtp.close()def send(to, subject, content,content_type='html', files=[],pics=&#123;&#125;): server = &#123;&#125; server['name'] ='smtp.exmail.qq.com' server['user'] = 'email address' server['passwd'] = 'passwd' send_mail(server,'email address',to, subject, content,content_type,files,pics)def useage(): print '--title 邮件标题,不可少选项' print '--to 收件人列表，逗号分隔多个账户' print '--content 邮件内容' print '--attachs 附件列表，逗号分隔多个附件' print '--type 取值:html,plain两种，默认html' print '''--pics 正文中图片，字典格式：&#123;"图片路径","图片标识（eg:&lt;imgage1&gt;正文中使用&lt;img src='cid:imgage1' &gt;来引用，标识两侧尖括号不能少）"&#125;'''def main(argv): try: opts,args = getopt.getopt(argv[1:],'',['to=','title=','content=','attachs=','type=','pics=']) except getopt.GetoptError, err: print str(err) print useage() sys.exit(2) title = '' tolist = [] content = '' attachs = [] type = 'html' pics = &#123;&#125; for k,v in opts: if k == '--title': title = v if k == '--to': tolist = v.split(",") elif k == '--content': content = v elif k == '--attachs': attachs = v.split(",") elif k == '--type': type = v elif k == '--pics': pics = eval(v) if title == '': print 'please input title...' sys.exit(1) if type not in ('html','plain'): print 'content type only supports:html,plain...' sys.exit(1) if tolist == []: print 'please input mail receiver...' sys.exit(1) send(tolist, title, content,type, attachs,pics)if __name__ == '__main__': main(sys.argv)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-format Usage]]></title>
    <url>%2F2017%2F06%2F09%2FPython-format%2F</url>
    <content type="text"><![CDATA[foramt函数：“映射”示例通过位置123456In [1]: '&#123;0&#125;,&#123;1&#125;'.format('kzc',18)Out[1]: 'kzc,18' In [2]: '&#123;&#125;,&#123;&#125;'.format('kzc',18) Out[2]: 'kzc,18' In [3]: '&#123;1&#125;,&#123;0&#125;,&#123;1&#125;'.format('kzc',18) Out[3]: '18,kzc,18' 字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次，不过2.6不能为空{}，2.7才可以。 通过关键字参数1In [5]: '&#123;name&#125;,&#123;age&#125;'.format(age=18,name='kzc') Out[5]: 'kzc,18' 通过对象属性12class Person: def init(self,name,age): self.name,self.age = name,age def str(self): return 'This guy is &#123;self.name&#125;,is &#123;self.age&#125; old'.format(self=self)In [2]: str(Person('kzc',18)) Out[2]: 'This guy is kzc,is 18 old' 通过下标12In [7]: p=['kzc',18] In [8]: '&#123;0[0]&#125;,&#123;0[1]&#125;'.format(p) Out[8]: 'kzc,18' 有了这些便捷的“映射”方式，我们就有了偷懒利器。基本的python知识告诉我们，list和tuple可以通过“打散”成普通参数给函数，而dict可以打散成关键字参数给函数（通过和*）。所以可以轻松的传个list/tuple/dict给format函数。非常灵活。 格式限定符它有着丰富的的“格式限定符”（语法是{}中带:号），比如：填充与对齐填充常跟对齐一起使用^、&lt;、&gt;分别是居中、左对齐、右对齐，后面带宽度:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充，比如 123456In [15]: '&#123;:&gt;8&#125;'.format('189') Out[15]: ' 189' In [16]: '&#123;:0&gt;8&#125;'.format('189') Out[16]: '00000189' In [17]: '&#123;:a&gt;8&#125;'.format('189') Out[17]: 'aaaaa189' 精度与类型f精度常跟类型f一起使用 12In [44]: '&#123;:.2f&#125;'.format(321.33345) Out[44]: '321.33' 其中.2表示长度为2的精度，f表示float类型。 其他类型主要就是进制了，b、d、o、x分别是二进制、十进制、八进制、十六进制。 12345678In [54]: '&#123;:b&#125;'.format(17) Out[54]: '10001' In [55]: '&#123;:d&#125;'.format(17) Out[55]: '17' In [56]: '&#123;:o&#125;'.format(17)Out[56]: '21' In [57]: '&#123;:x&#125;'.format(17) Out[57]: '11' 用，号还能用来做金额的千位分隔符。 12In [47]: '&#123;:,&#125;'.format(1234567890)Out[47]: '1,234,567,890']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>format</tag>
      </tags>
  </entry>
</search>